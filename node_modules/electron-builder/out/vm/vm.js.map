{"version":3,"file":"vm.js","sourceRoot":"","sources":["../../src/vm/vm.ts"],"names":[],"mappings":";;;;;;;;;;;;;;oEAuBO,AAAK,WAAuB,AAAwB;AACzD,cAAM,AAAM,UAAI,MAAM,AAAW,uDAAC,AAAW,AAAC,AAAC,cAAC,AAAM;AAAC,AAAE,AAAC,AAAE,mBAAC,AAAE,GAAC,AAAE,OAAK,AAAQ,AAAC;SAAjE;AACf,AAAE,AAAC,YAAC,AAAM,OAAC,AAAM,WAAK,AAAC,AAAC,GAAC,AAAC;AACxB,kBAAM,IAAI,AAAK,MAAC,AAAiF,AAAC,AACpG;AAAC;AAED,AAAiC;AACjC,AAAM,eAAC,AAAI,AAAkB,oEAAQ,AAAI;AAAC,AAAE,AAAC,AAAE,mBAAC,AAAE,GAAC,AAAK,UAAK,AAAS,AAAC;SAAzC,AAAM,YAA8C,AAAI;AAAC,AAAE,AAAC,AAAE,mBAAC,AAAE,GAAC,AAAK,UAAK,AAAW,AAAC;SAA3C,AAAM,KAAyC,AAAM,OAAC,AAAC,AAAC,AAAC,AACtI;AAAC;;;;;;;;;AA/BD,AAAO,AAAK,AAAI,AAAM,AAAM;;;;AAE5B,AAAO,AAAe,AAAI,AAAqB,AAAK,AAAE,AAAM,AAAc;;;;;;AAC1E,AAAO,AAAE,AAAkB,AAAE,AAAW,AAAE,AAAM,AAAe,AAE/D,AAAM;;;;;;;AACJ,QAAI,AAAO;AACT,AAAM,eAAC,AAAI,MAAC,AAAG,AACjB;AAAC;AAED,AAAI,SAAC,AAAY,MAAE,AAAmB,MAAE,AAAyB,SAAE,AAAe,kBAAG,AAAI;AACvF,AAAM,eAAC,AAAI,gDAAC,AAAI,MAAE,AAAI,MAAE,AAAO,SAAE,AAAe,AAAC,AACnD;AAAC;AAED,AAAK,UAAC,AAAY,MAAE,AAAmB,MAAE,AAAsB,SAAE,AAAgC;AAC/F,AAAM,eAAC,AAAK,iDAAC,AAAI,MAAE,AAAI,MAAE,AAAO,SAAE,AAAY,AAAC,AACjD;AAAC;AAED,AAAQ,aAAC,AAAY;AACnB,AAAM,eAAC,AAAI,AACb;AAAC,AACF,AAED,AAAM","sourcesContent":["import * as path from \"path\"\nimport { SpawnOptions, ExecFileOptions } from \"child_process\"\nimport { DebugLogger, exec, ExtraSpawnOptions, spawn } from \"builder-util\"\nimport { ParallelsVmManager, parseVmList } from \"./ParallelsVm\"\n\nexport class VmManager {\n  get pathSep(): string {\n    return path.sep\n  }\n\n  exec(file: string, args: Array<string>, options?: ExecFileOptions, isLogOutIfDebug = true): Promise<string> {\n    return exec(file, args, options, isLogOutIfDebug)\n  }\n\n  spawn(file: string, args: Array<string>, options?: SpawnOptions, extraOptions?: ExtraSpawnOptions): Promise<any> {\n    return spawn(file, args, options, extraOptions)\n  }\n\n  toVmFile(file: string): string {\n    return file\n  }\n}\n\nexport async function getWindowsVm(debugLogger: DebugLogger): Promise<VmManager> {\n  const vmList = (await parseVmList(debugLogger)).filter(it => it.os === \"win-10\")\n  if (vmList.length === 0) {\n    throw new Error(\"Cannot find suitable Parallels Desktop virtual machine (Windows 10 is required)\")\n  }\n\n  // prefer running or suspended vm\n  return new ParallelsVmManager(vmList.find(it => it.state === \"running\") || vmList.find(it => it.state === \"suspended\") || vmList[0])\n}"]}
