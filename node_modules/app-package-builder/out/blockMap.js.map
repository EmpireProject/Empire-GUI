{"version":3,"file":"blockMap.js","sourceRoot":"","sources":["../src/blockMap.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { hashFile } from \"builder-util\"\nimport { PackageFileInfo } from \"builder-util-runtime\"\nimport { BlockMap, SIGNATURE_HEADER_SIZE, BlockMapFile } from \"builder-util-runtime/out/blockMapApi\"\nimport { close, open, stat, write, writeFile } from \"fs-extra-p\"\nimport { Archive } from \"./Archive\"\nimport { ContentDefinedChunker } from \"./ContentDefinedChunker\"\nimport { SevenZArchiveEntry } from \"./SevenZArchiveEntry\"\nimport { SevenZFile } from \"./SevenZFile\"\n\nconst deflateRaw: any = BluebirdPromise.promisify(require(\"zlib\").deflateRaw)\nconst gzip: any = BluebirdPromise.promisify(require(\"zlib\").gzip)\n\n/*\nApproach like AppX block map, but with one difference - block not compressed individually, instead, the whole file is compressed using LZMA compression.\nSee (Package File in the developer readme) about compression. So, delta will be not ideal (because compressed data can change not only actually changed block in the file, but others,\nand we don't set even dict size and default 64M is used), but full package size will be still relative small and will save initial download time/costs.\n */\n\n// reduce dict size to avoid large block invalidation on change\nexport async function createDifferentialPackage(archiveFile: string, isAppendToFile = true): Promise<PackageFileInfo> {\n  const fd = await open(archiveFile, \"a+\")\n  try {\n    if (!archiveFile.endsWith(\".7z\")) {\n      const blockMap = await doComputeBlockMap([{\n        name: \"file\",\n        dataStart: 0,\n        dataEnd: (await stat(archiveFile)).size,\n      }], fd)\n      // for AppImage allow to easily detect blockMap data size without update metadata\n      const blockMapFileData = await serializeBlockMap(blockMap, archiveFile, !isAppendToFile)\n      if (isAppendToFile) {\n        await appendBlockMapData(fd, blockMapFileData, true)\n      }\n      else {\n        await close(fd)\n      }\n      return await createFileInfo(blockMapFileData, archiveFile)\n    }\n\n    // compute block map using compressed file data\n    const sevenZFile = new SevenZFile(fd)\n    await sevenZFile.read()\n    const blockMap = await computeBlockMap(sevenZFile)\n    const blockMapFileData = await serializeBlockMap(blockMap, archiveFile, false)\n    await appendBlockMapData(fd, blockMapFileData, false)\n    const result = await createFileInfo(blockMapFileData, archiveFile)\n    result.headerSize = sevenZFile.archive.headerSize\n    return result\n  }\n  catch (e) {\n    await close(fd)\n    throw e\n  }\n}\n\nasync function serializeBlockMap(blockMap: BlockMap, archiveFile: string, isUseGzip: boolean) {\n  // lzma doesn't make a lof of sense (151 KB lzma vs 156 KB deflate) for small text file where most of the data are unique strings (encoded checksums)\n  // protobuf size â€” BlockMap size: 153104, compressed: 151256 So, it means that it doesn't make sense - better to use deflate instead of complicating (another runtime dependency (google-protobuf), proto files and so on)\n  // size encoding in a form where next value is a relative to previous doesn't make sense (zero savings in tests), since in our case next size can be less than previous (so, int will be negative and `-` symbol will be added)\n  // sha2556 secure hash is not required, md5 collision-resistance is good for our purpose, secure hash algorithm not required, in any case sha512 checksum is checked for the whole file. And size of matched block is checked in addition to.\n  const blockMapDataString = JSON.stringify(blockMap)\n  const blockMapFileData: Buffer = await (isUseGzip ? gzip : deflateRaw)(blockMapDataString, {level: 9, chunkSize: 1024 * 1024})\n\n  if (process.env.DEBUG_BLOCKMAP) {\n    const buffer = Buffer.from(blockMapDataString)\n    await writeFile(`${archiveFile}.blockMap.json`, buffer)\n    console.log(`BlockMap size: ${buffer.length}, compressed: ${blockMapFileData.length}`)\n  }\n  return blockMapFileData\n}\n\nasync function appendBlockMapData(fd: number, blockMapFileData: Buffer, addLength: boolean) {\n  // Compatibility with nodejs 6, because:\n  // v7.2.0 The offset and length parameters are optional now.\n  await write(fd, blockMapFileData, 0, blockMapFileData.length)\n  if (addLength) {\n    const sizeBuffer = Buffer.alloc(4)\n    sizeBuffer.writeUInt32BE(blockMapFileData.length, 0)\n    await write(fd, sizeBuffer, 0, sizeBuffer.length)\n  }\n\n  await close(fd)\n}\n\nasync function createFileInfo(blockMapFileData: Buffer, archiveFile: string) {\n  const packageFileInfo = await createPackageFileInfo(archiveFile, blockMapFileData.length)\n  packageFileInfo.blockMapData = blockMapFileData\n  return packageFileInfo\n}\n\nexport async function createPackageFileInfo(file: string, blockMapSize: number): Promise<PackageFileInfo> {\n  return {\n    path: file,\n    size: (await stat(file)).size,\n    blockMapSize,\n    sha512: await hashFile(file),\n  }\n}\n\nclass BlockMapBuilder {\n  private currentFolderIndex = -1\n\n  constructor(private readonly archive: Archive) {\n  }\n\n  // noinspection BadExpressionStatementJS\n  buildFile(file: SevenZArchiveEntry) {\n    const archive = this.archive\n\n    const folderIndex = file.blockIndex\n    if (folderIndex < 0) {\n      // empty file\n      file.dataStart = 0\n      file.dataEnd = 0\n      return\n    }\n\n    if (folderIndex === this.currentFolderIndex) {\n      throw new Error(\"Solid not supported\")\n    }\n\n    this.currentFolderIndex = folderIndex\n\n    const folder = archive.folders[folderIndex]\n    const firstPackStreamIndex = folder.firstPackedStreamIndex\n    const folderOffset = SIGNATURE_HEADER_SIZE + archive.packPosition + archive.streamMap.packStreamOffsets[firstPackStreamIndex]\n\n    let size = 0\n    for (let i = 0; i < folder.packedStreams.length; i++) {\n      size += archive.packedSizes[firstPackStreamIndex + i]\n    }\n\n    file.dataStart = folderOffset\n    file.dataEnd = folderOffset + size\n    // console.log(`${file.name} ${size}, ${folder.totalInputStreams}`)\n  }\n}\n\nexport interface SubFileDescriptor {\n  name: string\n\n  dataStart: number\n  dataEnd: number\n}\n\nexport async function computeBlockMap(sevenZFile: SevenZFile): Promise<BlockMap> {\n  const archive = sevenZFile.archive\n  const builder = new BlockMapBuilder(archive)\n\n  const files: Array<SubFileDescriptor> = []\n  for (const file of archive.files) {\n    if (!file.isDirectory) {\n      builder.buildFile(file)\n      // do not add empty files\n      if (file.dataStart !== file.dataEnd) {\n        files.push(file)\n      }\n    }\n  }\n\n  return await doComputeBlockMap(files, sevenZFile.fd)\n}\n\nasync function doComputeBlockMap(files: Array<SubFileDescriptor>, fd: number): Promise<BlockMap> {\n  // just to be sure that file data really doesn't have gap and grouped one by one\n  for (let i = 0; i < (files.length - 1); i++) {\n    if (files[i].dataEnd !== files[i + 1].dataStart) {\n      throw new Error(\"Must be no gap\")\n    }\n  }\n\n  const stats: Array<string> = []\n  const blocks = await BluebirdPromise.map(files, async (file): Promise<BlockMapFile> => {\n    const chunker = new ContentDefinedChunker()\n    const blocks = await chunker.computeChunks(fd, file.dataStart, file.dataEnd, file.name)\n\n    if (process.env.DEBUG_BLOCKMAP) {\n      stats.push(getStat(blocks.sizes, file.name))\n    }\n\n    return {\n      name: file.name.replace(/\\\\/g, \"/\"),\n      offset: file.dataStart,\n      ...blocks,\n    }\n  }, {concurrency: 2})\n\n  if (process.env.DEBUG_BLOCKMAP) {\n    let duplicate = 0\n    let savedSize = 0\n    // noinspection JSMismatchedCollectionQueryUpdate\n    const checksums: Array<string> = []\n    // noinspection JSMismatchedCollectionQueryUpdate\n    const sizes: Array<number> = []\n    const index = new Map<string, number>()\n    for (const file of blocks) {\n      for (let i = 0; i < file.checksums.length; i++) {\n        const checksum = file.checksums[i]\n        const size = file.sizes[i]\n        if (index.has(checksum)) {\n          duplicate++\n          savedSize += size\n        }\n        else {\n          index.set(checksum, checksums.length)\n          checksums.push(checksum)\n          sizes.push(size)\n        }\n      }\n    }\n\n    console.log(stats.join(\"\\n\"))\n    console.log(`duplicates: ${duplicate}, saved: ${savedSize}`)\n  }\n\n  return {\n    version: \"2\",\n    files: blocks,\n  }\n}\n\nfunction getStat(sizes: Array<number>, name: string) {\n  const sortedSizes = sizes.slice().sort((a, b) => a - b)\n  const middle = Math.floor(sortedSizes.length / 2)\n  const isEven = sortedSizes.length % 2 === 0\n  const median = isEven ? (sortedSizes[middle] + sortedSizes[middle - 1]) / 2 : sortedSizes[middle]\n  return `${sizes.length} chunks generated for ${name} (min: ${sortedSizes[0]}, max: ${sortedSizes[sortedSizes.length - 1]}, median: ${median})`\n}"]}
