"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TmpDir = undefined;
exports.getTempName = getTempName;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(require("bluebird-lst"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _path = _interopRequireWildcard(require("path"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let tmpFileCounter = 0;
const tmpDirManagers = new Set();
// add date to avoid use stale temp dir
const tempDirPrefix = `${process.pid.toString(16)}-${Date.now().toString(16)}`;
function getTempName(prefix) {
    return `${prefix == null ? "" : `${prefix}-`}${tempDirPrefix}-${(tmpFileCounter++).toString(16)}`;
}
const tempDir = new (_lazyVal || _load_lazyVal()).Lazy(() => {
    let promise;
    const systemTmpDir = process.env.TEST_TMP_DIR || process.env.ELECTRON_BUILDER_TEST_DIR || (0, (_os || _load_os()).tmpdir)();
    if ((_fsExtraP || _load_fsExtraP()).mkdtemp == null) {
        const dir = _path.join(systemTmpDir, getTempName("temp-files"));
        promise = (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(dir, { mode: 448 }).then(() => dir);
    } else {
        promise = (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${_path.join(systemTmpDir, "temp-files")}-`);
    }
    return promise.then(it => (0, (_fsExtraP || _load_fsExtraP()).realpath)(it)).then(dir => {
        require("async-exit-hook")(callback => {
            const managers = Array.from(tmpDirManagers);
            tmpDirManagers.clear();
            if (callback == null) {
                for (const manger of managers) {
                    manger.cleanupSync();
                }
                try {
                    (0, (_fsExtraP || _load_fsExtraP()).removeSync)(dir);
                } catch (e) {
                    handleError(e, dir);
                }
                return;
            }
            // each instead of map to avoid fs overload
            (_bluebirdLst || _load_bluebirdLst()).default.each(managers, it => it.cleanup()).then(() => (0, (_fsExtraP || _load_fsExtraP()).remove)(dir)).then(() => callback()).catch(e => {
                try {
                    handleError(e, dir);
                } finally {
                    callback();
                }
            });
        });
        return dir;
    });
});
function handleError(e, file) {
    if (e.code !== "EPERM" && e.code !== "ENOENT") {
        // use only console.* instead of our warn on exit (otherwise nodeEmoji can be required on request)
        console.warn(`Cannot delete temporary "${file}": ${(e.stack || e).toString()}`);
    }
}
class TmpDir {
    constructor() {
        this.tempFiles = [];
        this.registered = false;
    }
    getTempDir(options) {
        return this.getTempFile(options, true);
    }
    createTempDir(options) {
        return this.getTempFile(options, true).then(it => (0, (_fsExtraP || _load_fsExtraP()).mkdir)(it).then(() => it));
    }
    getTempFile(options) {
        let isDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return tempDir.value.then(it => {
            if (!this.registered) {
                this.registered = true;
                tmpDirManagers.add(this);
            }
            const prefix = nullize(options == null ? null : options.prefix);
            const suffix = nullize(options == null ? null : options.suffix);
            const namePrefix = prefix == null ? "" : `${prefix}-`;
            const nameSuffix = suffix == null ? "" : suffix.startsWith(".") ? suffix : `-${suffix}`;
            const result = `${it}${_path.sep}${namePrefix}${(tmpFileCounter++).toString(16)}${nameSuffix}`;
            this.tempFiles.push({
                path: result,
                isDir,
                disposer: options == null ? null : options.disposer
            });
            return result;
        });
    }
    cleanupSync() {
        const tempFiles = this.tempFiles;
        tmpDirManagers.delete(this);
        this.registered = false;
        if (tempFiles.length === 0) {
            return;
        }
        this.tempFiles = [];
        for (const file of tempFiles) {
            if (file.disposer != null) {
                // noinspection JSIgnoredPromiseFromCall
                file.disposer(file.path);
                continue;
            }
            try {
                if (file.isDir) {
                    (0, (_fsExtraP || _load_fsExtraP()).removeSync)(file.path);
                } else {
                    (0, (_fsExtraP || _load_fsExtraP()).unlinkSync)(file.path);
                }
            } catch (e) {
                handleError(e, file.path);
            }
        }
    }
    cleanup() {
        const tempFiles = this.tempFiles;
        tmpDirManagers.delete(this);
        this.registered = false;
        if (tempFiles.length === 0) {
            return (_bluebirdLst || _load_bluebirdLst()).default.resolve();
        }
        this.tempFiles = [];
        return (_bluebirdLst || _load_bluebirdLst()).default.map(tempFiles, it => {
            if (it.disposer != null) {
                return it.disposer(it.path);
            }
            return (it.isDir ? (0, (_fsExtraP || _load_fsExtraP()).remove)(it.path) : (0, (_fsExtraP || _load_fsExtraP()).unlink)(it.path)).catch(e => {
                handleError(e, it.path);
            });
        }, { concurrency: 8 });
    }
}
exports.TmpDir = TmpDir;
function nullize(s) {
    return s == null || s.length === 0 ? null : s;
}
//# sourceMappingURL=main.js.map